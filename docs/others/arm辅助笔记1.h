
	swap分区
	1字节：8bit 0~255

	0x400: 		1KB 
	0x1000: 	4KB		0xC000: 48K
	0x10000:	64KB 	0x50000: 320K
	0x100000:	1MB		0xD00000: 13M
	0x1000000: 	16MB
	0x1000,0000: 256MB	0xC000,0000: 256*12 = 3GB 


	char *tmp = malloc(100M);
	tmp为0xB000,0000，一共100M
	for (i=0; i<100M; i++)
		tmp[i] = 0x0;
	
	*(tmp+0x8056) = 0x5;

	cpu得到地址0xB000,2056，将该地址提交给MMU；
	mmu查页表，页表是按页映射的，大小是４K(0x1000);地址2056对应第三个4K;
	mmu找0xB000,0000开始的页表项+3的位置；
	页表第三项中存储0x4700,3000(物理页的首地址)
	最终要访问的物理地址为0x4700,3000+0x56

	通过地址总线，将0x5写入0x4700,3056


	linux内核的buddy系统:
	底层的内存管理系统;
	有了虚拟地址，可以分配虚拟连续的大量内存；


	4G * 128 = 512G 

	物理地址的范围：
	比如处理器有32根物理地址，则范围为0x0~0xffff,ffff(4G)
	32位的arm处理器一般都是４G的物理空间；
	64位的arm处理器一般物理总线会超过32根，具体多少要看处理器；
	一般可能会扩展到48bit, x86为39bit;

	虚拟地址的范围：
	如果为32位arm处理器，则虚拟地址范围0x0~0xffff,ffff(4G)
	如果64位的arm或x86处理器，指针变为8个字节，如果虚拟空间扩展为64位则太大，
	所以一般都采用48bit空间; 0x0~0xffff,ffff,ffff (256T)
	对linux来说，一般用户态256T, 内核态256T



	状态寄存器：硬件置位，软件读取或者要负责清零；
	软件一般通过读状态寄存器，了解cpu或外设的工作状态；

	控制寄存器：写入不同的值，可以让硬件按照不同的模式工作；
	比如gpio寄存器，向给定的bit写1，则芯片外部的gpio引脚输出高电平；

	数据寄存器：用于收发数据；比如uart控制器的收发寄存器；
	如果从串口接收到１个字节的数据，则硬件存储到Rx寄存器，软件负责读取；
	如果软件要通过串口向外发送１个字节数据，则写入Tx寄存器，硬件负责从Tx中读取数据，按位发送...
	mov r1, #5
	str r1, [0x8000]
	检查状态寄存器，如果5发送完成，可以继续发送;
	mov r1, #6
	str r1, [0x8000]



	pc: program counter(程序计数器)

	每个时钟周期都可以取一条arm指令执行；
	pc: 上电时从0x0开始；cpu根据pc中的地址，从内存中取指令；
	如果指令为３２位，则每个时钟周期pc默认加4;

	bl / b 的工作就是改变pc的值
	也可以直接改pc
	mov pc, #0x8000




	r13别名为sp, r14别名lr

b(branch, 分支)

	bl abc //bl跳转到标号abc,同时将bl后面的一条指令的地址存储在r14(lr)中
	


abc:
	mov ...
	...;
	mov pc, lr //将lr中存储的地址赋值给pc寄存器，程序跳转回bl abc后面的一条指令继续执行

	




	mov r8, #5	//usr
	mov r8, #10 //fast irq



	mov r0, #5
	mov r1, r0
	mov r1, r0, lsr 3
	cmp r1, r2
	add r1, r2, #10


	strcmp 库函数，系统调用　　libc 

	strcmp
	malloc / calloc /realloc
	sys_brk

	fopen  FILE *
	sys_open



	char *tmp = 0x8000;
	*tmp = 0x20; //将0x20写入地址0x8000


	malloc(100M);
	改页表，完成100M虚拟空间的映射；
	没有真正分配内存；

	当访问malloc返回的空间时，真正分配内存；



	arm-linux-gcc -s hello.c 

	通用寄存器(Register):
	arm设计的;
	位于cpu核内部，在汇编语言中直接使用;
	数量有限; 压栈出栈

	特殊功能寄存器(SFR, Special Functional Register)
	位于处理器的外设里面，比如串口，GPIO，查看6818或stm32的手册，
	能够找到SFR的物理地址(三星或意法在设计芯片时指定);
	SFR用于控制外设；

	中断：一定是硬件产生，会引起软件的中断处理
	中断线：外设一旦要产生中断，会改变特定中断线上的电平
	


